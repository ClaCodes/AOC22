#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

char directionsEX[] = ">>><<><>><<<>><>>><<<>>><<<><<<>><>><<>>";
char directions[] = ">>><<<>><<<>>><<<>>><<<>><<><>>><<>>><>><<<>>><<><>>><<<<>>>><>><<>>>><>>>><<<<>>>><<<>>><>><<>><<<>><<<<><<>><<><<<>><<>>><<<>>>><>>><>><><<<<><>><><<>>>><<><<<<><<<><<>>>><<><<>><<<<>>>><>>>><>><><<<>>>><>>>><>><<>>>><>>>><<><<<<>><<>>>><>>><>><>><<>><<<<>>>><<<>><<<><><<<<>><<><<<<><<<><<<<>>>><<><<<>>><<>><>><<><<<<>>>><<<>>>><<<<>><<<<>><<>>>><<><>><>>>><<<<>>>><<>>><<<><<<<>>><>><<<>>><<<>>>><<<>>>><>>>><>>><<<<>>>><<<>>><<<<>>><><<>>><<<>>>><<<>>>><>>>><<<<>><<>>><<<<><>>>><><<<<>>><<<<>>>><<<>>>><<>>><>><<>><<>><<>>><<>>>><>>><<<><<<>><<<<>>><<<>>><<<><>>><<<<><>><<<>>>><><<<<><<>><<<<>><<<>>><>><<><><<<>><<<>>><<>>>><<>><><<>>>><<<<>>><<<>><<<<>><<><<<>>>><>>><>><<<>>>><<<>>><>><<<<><><<>><<<>><<<<>>>><<<<>>><<<<>><>>>><>>><>>><<>>><<<<>><<><<<<>>>><<<<>>>><<<><<>><><<<>>><>><<>><<<>>><>>><<<<>><>><><<><>><>>><>>>><<<>>><<<<>>>><<<>>>><<<>><<<<>>>><<<>>><><<>>><>>><<<>>><<<<><>>>><<<><>>>><>>><<>>><>><<<<>>><<>><<<<>><<>>>><<<><<><><<<>><<<<>>><<<><<<<>>>><<<<>>>><<<<>><<>>><<<><<<<><<<>>><><<<<><>><<><<<<>>><<>><>><<<><<<>>><<>><<<<><<<>><<<<>>><<>>><<<>>>><<<>><<<>>>><><<>><>>><<<>><><>><<>>><<<<>>><<>>>><>><<><<<>>>><<<>>><<>><<<<>>><<<<><<<<><<>>>><>><><<<>>>><<<<>><<<<>><>><<>><<<>><><<<<>>>><<<<>>>><<<>>>><>><<>><<<><<<<>><<<<><<<><<<>>><<<>><>>><<>><<><<>><<>><<><<<><<<<>>>><<<><>>>><<>><<>>><>>><<>>><><<>>><<<>>>><<<<>>>><><<<>>><<>>>><<<<><>>><>><<>><<<><><>>><<<>>>><>>><<><>>><<>>><<<>>><<<><<<>>><<<<><<<<>>>><<<>>>><<<<>>>><<<>>><<>><<>>><<<<>><><<<><<><<<>>>><<<<>>><>><<<<><<<>>>><<<<>>>><<<>><>>>><<<><<<<>>>><>>>><<>>>><<<><<<<><<>><>>>><<<>>>><<<<>>><>>>><<<><<>>><<>><<<>><>><<<>>><<>>>><<>>><<>>>><<><<>>>><<<<>>><<<<>>><<<>>><>><<><<<<>>>><<<>>><><<<<>>><<>>><<>><<<>><<<<><><<<<>>>><<<><<>>>><<<>>>><>><<<>>>><>>>><><<<<>><<<>>><>>><>>><<<>><<<<><>>><<>>><<<>>>><>>>><><<<<>>>><<>>><>>><<<<><<>>><<<><<<>>>><<<<><><<<<><<<<>><<<><>><<<<>>><>><<><<>>><<<>>><<<<>><<<>>><<<>>>><<<<>>><>><>><<<<>>>><>>><<<<>>><<>>><>><<<><>>>><<<<><<<>><><<<<>><<<<>>>><>><>><>>>><<<>>>><<>>>><<<>>><<<<>>>><<<<>>>><<><><<<>>><<>>><<<<>>>><<<<><<>>>><<<><<<<>>>><<>><<<>><<><>><<<<>>><<<<>>><<<<>>><<>>>><<<<>><<>>><<>>><>>>><<<>>>><<>>><<<<><<<>>><<<<><<><<>>><<>>>><<<<>>><<>>><<<<>>>><<<<>>><<<<><>><<<>>>><<<<>><<<>>><<<><<>>>><>>><<>>><>>>><<<><<<<><<<><<<>>>><<>>>><>>><>>>><<>>>><<<<>>>><>><<<<><<<>>>><><<>>>><<><<<>><<<<>>>><<<<><<<><<<<>>>><>><><<<<>><<<<>>><<>><<>>><>>><<<>>>><<<<>>><<<<>>><<>>>><<>><>><<<<>>>><<<>><<>><><><<>><<<<>>><<><<<<><><<<>>>><<<<>>><<<<>>>><<<>>><<<<><<<<>>><<><<><<>>><<<><<>><>>>><<<>><<>>><<<<>>>><>>>><<<>>>><<<<>><<><<<>>>><<<>>><>>>><<<<>>>><<<<><<>>><<<<>>>><<>>>><<<<><<<<>>><<>>><><<<<><<>>><>>>><<><<<>>>><>>><<<>><<<>><<<<>><>>>><<<>><<<<><>>>><<<>><<<<>>>><<<<>><<<<>><<>>><>>>><<>>><<<<><<>><>><<<<>>>><<<<>>>><<>><<<<><<<<><<>><><<>>>><<<<>>><<<<>><<<<>><<<<>><<<<>>><<<<>>><<<<><<<>>><><>>>><<>><>>><<>>><<<>>><<><>>>><<<<>>><<<>><<<<>>><<<>>><<>><<>><><<>><<>><<>>>><>>><<<>>>><<<<>>>><<<>><>>>><<<>>><<<><<>>>><<<>><<<<>><<<>>><<<<>><<><<<>>>><<>><>>>><<<<><>>>><<><<<<>><<>>><<>><<<<>>>><<>>><<>><<>>><>>>><<<>><<<><>><<<<>>><<<>>><<><<>>>><<<><>>>><>><<<>><><<<<>><<<<>>>><<<<>><><<<>>>><><<<<>>>><<>>><>>>><<>><>><<<><>><<<>>>><>><<<><<><><<<>>><<>><<<<>><<<>>><<>><<><>><<<<>>>><<<<>><<>>>><<<>><<><>>>><<<<>>>><>>><<>>><><<<<>><<>><>>>><<<<>>>><><<>>>><>>>><<<<>>>><<<<><>><><<<>>>><>>><<><><<<><<<<>>>><<<<>><<<>>>><<<<>>>><<<<>><<>>>><>><>>>><<<<><<>><<<><<<>>>><<<>>><<>>>><>><<<<>><<<>>>><<>>>><<<<>>>><<<<><<<>><>><><><<<><<<><<<><<<<>>><<>>><<>>><<<>><<<><<<<><<>>>><>><>><<<>>><<<<>>>><<<<>>><<<<>>><<<>>>><<>><<>><>><<>>><<>>>><<<<>>>><>>>><><><<<<><<<<>><<<><<<>>><<>>><<<>>>><<>>>><<>>><<<<>>>><<<><<<<>>><<<<><<>>>><<<<>>><>><><<>>><>>>><>>><<<>><<<<>><<<>>>><<>><<<>>>><<<><<<<>>><<<<><<<><<<>><<<>>>><<>>><>><<<<>>><<<>><>>>><<><><<<><><<<>>>><<<>><<><<<>>>><<<>>>><>>>><<<>>><<<>>><<<<>><<>><>><<>><>>><<><>><>>>><<<><<<><<<><<<<>><<>>>><>>>><>>><<<<><<<<>>>><<><<<>>><<<>>>><<<>>><<>>>><<>><><<<>><<<<>>>><<<<><<>><>><<<>><><<>><<<<>>><>>>><<<>><<<>><<<>>><<><<<><>><><><<>><<<>>><<<><<<><>>>><>>>><>>><<<<>>>><><<<<>>><<>><<<<>><<>>><>>>><<>>><>>>><<<>>>><<<>>>><<<<>>><<<<>><<<>>><<<>><<<>>><<<<>>><<>>>><<>>>><<<<>>>><<<<>><<<>>><<<<>>><>>>><<<<><<<<>><<<<>>>><>>><<<>><<>>>><<><<>><<<>>><<<<><<<<>>>><<<<><<<>>>><<<<>>><><<<<><<<<>><><<<>>>><>><<<<>><><>><<<>>>><><<>>>><><<<>>>><>>><<<<>>>><<<<>>><<<<>><<>>>><>>>><>>><<<><<>>>><<<<><<<<>><><>><<<>><<><<<<>>><<<<>>>><<<>><>><<>>><<<>>><<<<>>><<<><>>><<<>>><<<>><<<>>>><<<>><<>>>><<<<>>><<<<>><<<><>><<<>><><<<>><<<<><><>><<<><>><><<<>>><>>>><>>>><<<>><<<>>>><<<>>><<<<>>><<<>>>><<>>>><>><<><<<>><<>>>><>>>><<>><<<<><<<>><<>><<<><<>>>><<<<><<<>>>><<><<>>>><<><>>><><<>>><<<><<><<<<>>><<>>><>>>><><>>><<<<>><<>><<>>>><<<<>>><<<>>><<><<<><<<<>>><<>>><>><>>>><<><<<>>><<<<>>>><<>><<<<>><>>><<<>>><<>>>><<<>><<><<<>>><><<>>><<><<>>><>>>><<<<>>>><<<<>>>><<<>>>><<<<>>>><><<<<>>><>>><<<<>>><<>><<<>>>><>>>><><<<>><<>><<<>>><<<<>>><<<>>>><><<<<>>>><<><<>>><<<<>>>><<>>><<<<><>>><<<>>><<><<><<<>><>>>><<<>>>><<<>><<<>><<>>><<>>>><<<><>>>><<<<>>><<<<>><<>><<<>>><<<<>><<<<>>>><<>><<>><<<<>>>><>>>><<<>><>>><><>>><>>>><<<>>>><<>><<<>><<>><>>>><<<>>>><<<<><>>><<><<><>>>><<>>>><>>><<<<>>>><>>>><<<><<<><>>><<<>>><>>><<<>><<<<>>><>>>><<><<<<><<<>>>><<<<><<<<>><<>>><<<<><<<<>>><<>>><<<>>>><<>>>><<<>>>><<>><<>>><<<>>><<>>><>>><<>><<>><<<<><<>>>><<<>>>><<<>><<<<>>>><<>>>><>>>><>><>>>><><<<>>>><<<>>><><<<<>>><<<>><<<>><<<<>><<<>>>><<<<>>>><>>>><>><<<><><>>><>>>><<<<>>>><<<>>>><<>><>>>><<<<><<<>>>><>><<<>><<<<>>>><>>><<<<>>><<<<>><<<>>><<<<>>>><<>>><<>><<<>>><>><<>>>><<<<>>><<<<>>><<<<><<<<>>>><<<<><<<<>><>>><><<<>>><<<<>><<<<>>>><<<>>><>>><>>><<<>>><>>>><>><<>><<<<><<><>>>><<<<>>>><<<<>>>><<<>>>><><<<<>>>><<>>><<<>>>><<>>>><<<>>>><<<>><<<>><<>><<>>>><>>><>>>><<<<>>><<<>><<>>>><>>>><<<><<><<<>><<<<>>>><<<><<<<>><<><<<>><<<<><>><<<<><<>>>><>>>><<><<<<>><<>><<<>>>><<>>>><<<<>>><<><<<>>>><<<<>>>><<<>>><>>>><<>>><<<<>>><<<<>>><<<<>>>><<>>>><<>>>><<<<>>>><<>>>><<>>><>><<<<>>><>>>><>><<>>><<<<>><<<>><<><<>>>><<<>><<>><>><<<>>>><<><<><<><<><<>>>><<<>><<>>>><>>><<<<><<><>>><<<><<<<>>>><<<>>><<<<>><>>>><>><<<>>><<<>>><<>><<<><<<<>>>><<<><<><<<>>><<<<>><>>><>>><<<<>>><><<<<>><<>>>><>><<>>><<><<>>><<<<>>>><>><<<><<<>>>><<<>>>><<<>><<<>>>><<><<<<><<<<>><<>>>><>>><>>><<<<>><>><>><<<>>><<>><><>>><<<<><<<<>>>><>>><<<><<><>>><<<<>>>><><>><<<><<<>>><>>><<>><<>>>><><>><>><<<>><<>>>><<<>><<<<>>>><<<>><<>>><<<<>>>><<<<><<<>><<<><>>>><<<<>>>><<<>><<<><<<>><>>>><>>><<><>><<>>>><<<<><><<>>><<<<>>><<<<>>><<>>><<>><<<<>>>><<<<>>>><><><<>><>>>><<>>><<<<>>>><<>><<<>><<<<>>><<>>><><<>><<>><<<>>>><>><<><<<<>><<<>><<<>>>><>><<<<>><><>>>><<<<>><<<>>><<<<>><<<>><><>>>><<>><>>>><<<<>>>><<<<>>><<<<><<<<><<>>><<<<>>><<<<>>><<<<>>>><>><<><<>><<>>>><<<<>>><<<<>><<<>><>>><<<<><<>>><<<>>>><<><<<>>>><<><>><<><><<<><<<<>>><>>><<>>>><<<<><<>><>>>><<>>>><<<<>>>><<<<>>><><<<<>>>><<>><<>><<<>>>><<>>><>>><>>>><<<<>>><<>>><><>>><<><>>>><<<<>>><<<>><<>><>>>><<><<<>>><<<>>>><<<>>>><<>>>><<<<>>>><<<<><<>>><<>>>><<>>>><<><<<>><<<<><<<<>><<>>>><<><<<<>>><<<><<<<>>><<<>>>><<>>><>><<>>><>>><<>><>>><>>>><<>><<<><<>>>><>>>><<<><>>>><<<<>>>><<<<><><>>><<<>>>><><>>>><<<>><>>><<<>>>><<><<><<<<>>>><>>><<<>><<<><>><<<><><<<>>>><<>><<><<<>>>><<<>>><<<>>>><<<>>>><<<><<>><<<>><><<<>>>><<<<>>><<>><>>>><>><<>>>><<<><<>><<<><<<>>>><<<<><<<<><><<<>>>><><<<<><<<>>>><<<<>><<>><><<<>>><>><<<<>><<<>>>><>>>><<<>>><<<<><<<>>><<>>>><<<<>><<<<>>><><<><<<<><<>><>>><>><>><<<<>>>><><<>>><<<<>>>><<<<>>>><<<>><><<<<>><>>>><<>>><<<<>>><<<>>>><<>>>><<<<><<<<>>><<<>>><<>>>><<<>>>><<<>>>><<<<><<<<>>><<>>>><>>><>><<>><<<>><<<>><>><<>><<><<<<>>>><<<>><<>><<<<>>><<<><><>><<<><<>><<<<>><<>>>><<><<<<>><<<<>>><<<<>>>><<<<>><<<<>><<<>>><>>>><<<>>><<<<>>>><><<<>>><<>>>><<<><<<>><<>>><>>><<>>><>>><<>>><<<><<<>>>><<>><<>><<>>><<>><<<>>>><<<>>>><<<>>><<<><><>>>><<<<><<<>>><<<><>><<<<>>>><<<>><<<<>>><<<>><><<<>><<<<>>><<<><<<>>>><><<<<>>><<<>><<<>><<<<>>><<<<>>><<<<>>>><<>>>><<<<>>><>><<<><<<><>><<<>>><<<>><<<<>><<<<><<><>>>><<><<<>>><<<<>>>><<>><>>>><<<<>>>><<><<<<>><<<<>>><<<>>>><>>>><>><<>><<<><><<<<>>>><><>>><<<>>><<<<>>><<<<>>>><<><<<>>><<>>>><<<><>><><<<<>>>><<<<>>>><<<>>><<<>>>><<>>>><<<>>>><<<>>><>><<<<>><><>><<<<>>>><>>>><<<>><<>>>><<><<<<>>><>>><<<>>>><<<<><<><>>><<<<><<<<>>><<>><><<<<>>>><<<>><>>>><>>>><<>><<<>>>><<<<>>><<<>>>><<<>>>><<>>><<<>>><<<<>><<<<>><>>><<>>><<>>>><<<<>>>><>>><>><<><>>><<<><<>>>><><<<>>><<<><<>>>><<<>>><><<<<>>><<><>>><<>>><>>>><><>><<>>><<>>>><<>>>><<<<>>><>><><<<<>>>><<<<>>><><<>><<<<>><<>><<<>>><<<<>>><<<>>><<<<>><><<<><<<>>>><>>>><<<<>><<<>>><<<><<><<<><>><><<<>>>><<<<>>><<<<>>><<<<><<<>>>><<<<>>>><<<>>><>><><<>><<<>><<><<<<>><<><<<>>><<>>><<>>>><<>>>><><>>>><<<>>>><<<<><<>><<<<>>>><<<>><<<<>><><>>><<<<>>>><<>>><<<>><<<>>><<>>>><<<><<<<>><<>><<<>><<>>>><<>><<<<>>><>>><>><>>>><<<>>><<>>><<<>><<>>><<<<><<<><<>>><<<<>>><>><><<<<><>><>>><>><<><<<<><<>>><>><>><<>>><<>>><>>><<<<>>><<<<>>><<><>><<<<>>><<<<><<>><<<><><>>><>>><<<<>>><<<><<<>><<><>>>><<>><<>><<<<><<<<>><<>>>><>><<><<<>>>><<<>>>><<><<<<>>>><<<>><<<>>>><<<><>>>><<<>><<>><<<>><<<<>>>><<<>>><<<>><<<>>>><<<>>><<>>><<<<>>>><>>>><<>>>><><<<<>><<><<><<>><>>><<>>>><<>>><<<<><<><>><<<<><>><<<<><<<<>><<>>><<<<><>>>><>><<<>>>><<<<>>>><<>><<<<>>><<>>>><<>>><<<<>><<<><<<<>><<<>>><<<>>>><<<>><>><<>>>><<><<><>><>>><>><<<>>><<>>><<<><<<<>>>><<<<>>><<<<>>><<>>><<<<>>>><<><><><>><<>>><<<>>><<<<><>>><>><>><<<<><<<<>><<<<>>><>>>><<<>>><<<>>>><<<>>>><<<<>>>><>>><<<<>>>><><<<><<>>><<<<>>><<>><<>><<<<>>>><<>><><<<<>><<<>>><<<>>><<<<>><<<>>>><<<<>>>><>>><>>>><<>>><<><<><<<>>><<<><<<><>>>><<<<><<>>><<<>><<<<><<<>>><><<<<>>>><<>>>><>>><>><>>>><<<<><<<><<<><<><<>>>><<>>><>>>><<<><<>>><<<>><<><<<><<<><<<>><>>><<<>><>>><<>><>><<<<>>>><<<<>>>><><<<<><<><<<<>>>><>>><<<>>>><>>>><<<>>><<<>>>><<<>>><<<>>>><>>><<<>><>>><<>>>><><<<>><<<><>>>><<<>>>><<<<><<<>>>><>>><<<>><<>><<<<>><<<><<>>><<<>>>><>>>><<<<>>><<<>><>>>><><<<<><<>>>><>>>><<<><<>>>><<<<>>><>>><>>>><><<>>>><<><><><<>><<>>><<<><<>>>><<><<>><<>>>><<<>>>><<><<><<>>><<<>><<<>>>><><<<>>>><<<<><>>>><<<>>><<>><>>>><<<<><<>>><<><>><";

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[23]))
#define ROW_WIDTH 7
#define ROW_CNT 400
#define MAX_STATE_CNT 100000

struct row {
    bool occupied[ROW_WIDTH];
    /* uint8_t occupied2; // TODO rename */
};

struct field {
    struct row rows[ROW_CNT];
    size_t offset;
};

enum direction {
    LEFT,
    RIGHT,
};

enum rock {
    ROCK_MINUS,
    ROCK_PLUS,
    ROCK_L,
    ROCK_I,
    ROCK_O,
};

struct position {
    int64_t x;
    int64_t y;
};

struct state {
    struct field field;
    int64_t rock_cnt;
    int64_t direction_index;
    struct position p;
};

struct state_cache {
    struct state states[MAX_STATE_CNT];
    size_t state_cnt;
};

const char* direction_text(enum direction d);
const char* rock_text(enum rock rock);
enum rock rock_type(int64_t i);
enum direction jet_direction(int64_t i);
int64_t rock_width(enum rock rock);
void field_occupy(struct field *field, struct position p);
void field_unoccupy(struct field *field, struct position p);
bool field_occupied(struct field *field, struct position p);
void occupy_all(struct field *field);
bool occupied(struct field *field, struct position p, enum rock rock);
void double_buffer_unoccupied(struct field *field, struct field *back_buffer, struct position p);
void occupy(struct field *field, struct position p, enum rock rock);
int64_t tower_height(struct field *field);
void print_field(struct field *field, int64_t x, int64_t y, enum rock rock);
bool all_occupied(struct field *field, int64_t y);

const char* direction_text(enum direction d)
{
    switch(d) {
        case LEFT : return "LEFT";
        case RIGHT: return "RIGHT";
        default   : fprintf(stderr, "unexpected enum direction %d", d);
                    exit(EXIT_FAILURE);
    }
}

const char* rock_text(enum rock rock)
{
    switch (rock) {
        case ROCK_MINUS: return "ROCK_MINUS";
        case ROCK_PLUS : return "ROCK_PLUS";
        case ROCK_L    : return "ROCK_L";
        case ROCK_I    : return "ROCK_I";
        case ROCK_O    : return "ROCK_O";
        default        : fprintf(stderr, "unexpected enum rock %d", rock);
                         exit(EXIT_FAILURE);

    }
}

enum rock rock_type(int64_t i)
{
    const enum rock order[] = {ROCK_MINUS, ROCK_PLUS, ROCK_L, ROCK_I, ROCK_O};
    i %= ARRAY_SIZE(order);
    return order[i];
}

int64_t direction_index(int64_t i)
{
    return i % (ARRAY_SIZE(directions) - 1);
}

enum direction jet_direction(int64_t in)
{
    int64_t i = direction_index(in);
    char c = directions[i];
    if(c=='<') {
        return LEFT;
    }else if(c=='>') {
        return RIGHT;
    } else {
        fprintf(stderr, "Unexpected input at %ld expected one of '<' or '>' got '%c' (ascii %d)", i, c, c);
        exit(EXIT_FAILURE);
    }
}

int64_t rock_width(enum rock rock)
{
    switch (rock) {
        case ROCK_MINUS:
            return 4;
        case ROCK_PLUS:
            return 3;
        case ROCK_L:
            return 3;
        case ROCK_I:
            return 1;
        case ROCK_O:
            return 2;
        default:
            fprintf(stderr, "unexpected enum rock %d", rock);
            exit(EXIT_FAILURE);
    }
}

void field_occupy(struct field *field, struct position p)
{
    if(p.y < 0 || p.y >= ROW_CNT || p.x < 0 || p.x >= ROW_WIDTH) {
        fprintf(stderr, "Attempted to occupy out of bounds at x=%ld y=%ld", p.x, p.y);
        exit(EXIT_FAILURE);
    }
    field->rows[p.y].occupied[p.x] = true;
}

void field_unoccupy(struct field *field, struct position p)
{
    if(p.y < 0 || p.y >= ROW_CNT || p.x < 0 || p.x >= ROW_WIDTH) {
        fprintf(stderr, "Attempted to occupy out of bounds at x=%ld y=%ld", p.x, p.y);
        exit(EXIT_FAILURE);
    }
    field->rows[p.y].occupied[p.x] = false;
}

bool field_occupied(struct field *field, struct position p)
{
    if(p.y < 0 || p.y >= ROW_CNT || p.x < 0 || p.x >= ROW_WIDTH) {
        // Out of bounds is considered occupied
        return true;
    }

    return field->rows[p.y].occupied[p.x];
}

void occupy_all(struct field *field)
{
    // TODO memset?
    size_t height = ARRAY_SIZE(field->rows);
    for(size_t i = 0; i < height; ++i) {
        struct row *row = &field->rows[i];
        for(size_t j = 0; j < ARRAY_SIZE(row->occupied); ++j) {
            field_occupy(field, (struct position){j, i});
        }
    }
}

bool occupied(struct field *field, struct position p, enum rock rock)
{
    switch (rock) {
        case ROCK_MINUS:
            return field_occupied(field, (struct position){p.x  , p.y  })
                || field_occupied(field, (struct position){p.x+1, p.y  })
                || field_occupied(field, (struct position){p.x+2, p.y  })
                || field_occupied(field, (struct position){p.x+3, p.y  });
        case ROCK_PLUS:
            return field_occupied(field, (struct position){p.x+1, p.y  })
                || field_occupied(field, (struct position){p.x  , p.y+1})
                || field_occupied(field, (struct position){p.x+1, p.y+1})
                || field_occupied(field, (struct position){p.x+2, p.y+1})
                || field_occupied(field, (struct position){p.x+1, p.y+2});
        case ROCK_L:
            return field_occupied(field, (struct position){p.x  , p.y  })
                || field_occupied(field, (struct position){p.x+1, p.y  })
                || field_occupied(field, (struct position){p.x+2, p.y  })
                || field_occupied(field, (struct position){p.x+2, p.y+1})
                || field_occupied(field, (struct position){p.x+2, p.y+2});
        case ROCK_I:
            return field_occupied(field, (struct position){p.x  , p.y  })
                || field_occupied(field, (struct position){p.x  , p.y+1})
                || field_occupied(field, (struct position){p.x  , p.y+2})
                || field_occupied(field, (struct position){p.x  , p.y+3});
        case ROCK_O:
            return field_occupied(field, (struct position){p.x  , p.y  })
                || field_occupied(field, (struct position){p.x+1, p.y  })
                || field_occupied(field, (struct position){p.x  , p.y+1})
                || field_occupied(field, (struct position){p.x+1, p.y+1});
        default:
            fprintf(stderr, "unexpected enum rock %d", rock);
            exit(EXIT_FAILURE);
    }
}

void double_buffer_unoccupied(struct field *field, struct field *back_buffer, struct position p)
{
    if(!field_occupied(field, p) && field_occupied(back_buffer, p)) {
        field_unoccupy(back_buffer, p);
        double_buffer_unoccupied(field, back_buffer, (struct position){p.x+1, p.y  });
        double_buffer_unoccupied(field, back_buffer, (struct position){p.x-1, p.y  });
        double_buffer_unoccupied(field, back_buffer, (struct position){p.x  , p.y+1});
        double_buffer_unoccupied(field, back_buffer, (struct position){p.x  , p.y-1});
    }
}

void occupy(struct field *field, struct position p, enum rock rock)
{
    switch (rock) {
        case ROCK_MINUS:
            field_occupy(field, (struct position){p.x  , p.y  });
            field_occupy(field, (struct position){p.x+1, p.y  });
            field_occupy(field, (struct position){p.x+2, p.y  });
            field_occupy(field, (struct position){p.x+3, p.y  });
            break;
        case ROCK_PLUS:
            field_occupy(field, (struct position){p.x+1, p.y  });
            field_occupy(field, (struct position){p.x  , p.y+1});
            field_occupy(field, (struct position){p.x+1, p.y+1});
            field_occupy(field, (struct position){p.x+2, p.y+1});
            field_occupy(field, (struct position){p.x+1, p.y+2});
            break;
        case ROCK_L:
            field_occupy(field, (struct position){p.x  , p.y  });
            field_occupy(field, (struct position){p.x+1, p.y  });
            field_occupy(field, (struct position){p.x+2, p.y  });
            field_occupy(field, (struct position){p.x+2, p.y+1});
            field_occupy(field, (struct position){p.x+2, p.y+2});
            break;
        case ROCK_I:
            field_occupy(field, (struct position){p.x  , p.y  });
            field_occupy(field, (struct position){p.x  , p.y+1});
            field_occupy(field, (struct position){p.x  , p.y+2});
            field_occupy(field, (struct position){p.x  , p.y+3});
            break;
        case ROCK_O:
            field_occupy(field, (struct position){p.x  , p.y  });
            field_occupy(field, (struct position){p.x+1, p.y  });
            field_occupy(field, (struct position){p.x  , p.y+1});
            field_occupy(field, (struct position){p.x+1, p.y+1});
            break;
    }
    // TODO very slow algorithm!!
    struct field back_buffer;
    occupy_all(&back_buffer);
    size_t height = ARRAY_SIZE(field->rows) - 1;
    double_buffer_unoccupied(field, &back_buffer, (struct position) {0, height});
    size_t skip = 0;
    for(size_t i = 0; i < height; ++i) {
        if(!all_occupied(&back_buffer, i)) {
            break;
        } else {
            skip = i;
        }
    }
    for(size_t i = 0; i < height; ++i) {
        size_t j = i + skip;
        if(j>=height) {
            break;
        }
        back_buffer.rows[i] = back_buffer.rows[j];
    }
    back_buffer.offset = field->offset + skip;
    *field = back_buffer;
}

bool all_occupied(struct field *field, int64_t y)
{
    struct row *row = &field->rows[y];
    for(size_t j = 0; j < ARRAY_SIZE(row->occupied); ++j) {
        if(!field_occupied(field, (struct position){j, y})) {
            return false;
        }
    }
    return true;
}

int64_t tower_height(struct field *field)
{
    size_t height = ARRAY_SIZE(field->rows);
    for(size_t i = 0; i < height; ++i) {
        struct row *row = &field->rows[i];
        bool row_empty = true;
        for(size_t j = 0; j < ARRAY_SIZE(row->occupied); ++j) {
            row_empty &= !field_occupied(field, (struct position){j, i});
        }
        if(row_empty) {
            return i;
        }
    }
    fprintf(stderr, "Could not find a row without rocks, When computing height of the tower\n");
    exit(EXIT_FAILURE);
}

void print_field(struct field *field, int64_t x, int64_t y, enum rock rock)
{
    fprintf(stderr, "Position x=%ld y=%ld %s\n", x, y, rock_text(rock));
    size_t height = tower_height(field) + 4;
    for(size_t i = 0; i < height; ++i) {
        int64_t ypos = height - i - 1;
        struct row *row = &field->rows[ypos];
        /* if(all_occupied(field, ypos)) { */
        /*     continue; */
        /* } */
        fprintf(stderr, "%5ld|", ypos);
        for(size_t j = 0; j < ARRAY_SIZE(row->occupied); ++j) {
            if(y==ypos && x==(int64_t)j) {
                fprintf(stderr, "@");
            } else {
                fprintf(stderr, row->occupied[j] ? "#" : ".");
            }
        }
        fprintf(stderr, "|\n");
    }
    fprintf(stderr, "     +");
    for(size_t j = 0; j < ARRAY_SIZE(field->rows[0].occupied); ++j) {
        fprintf(stderr, "-");
    }
    fprintf(stderr, "+\n\n");
}
bool compareable_row(struct row *a, struct row *b)
{
    for(size_t i = 0; i < ARRAY_SIZE(a->occupied); ++i) {
        if(a->occupied[i] != b->occupied[i]) {
            return false;
        }
    }
    return true;
}

bool compareable(struct state *a, struct state *b)
{
    if(rock_type(a->rock_cnt) != rock_type(b->rock_cnt)) {
        return false;
    }
    if(direction_index(a->direction_index) != direction_index(b->direction_index)){
        return false;
    }
    // offset is supposed to be different
    for(size_t i = 0; i < ARRAY_SIZE(a->field.rows); ++i) {
        if(!compareable_row(&a->field.rows[i], &b->field.rows[i])){
            return false;
        }
    }
    if(a->p.x != b->p.x || a->p.y != b->p.y){
        fprintf(stderr, "different position should not happen at this point\n");
        exit(EXIT_FAILURE);
    }
    return true;
}

void cache_state(struct state_cache *state_cache, struct state *state)
{
    if(state_cache->state_cnt >= ARRAY_SIZE(state_cache->states)) {
        fprintf(stderr, "Increase MAX_STATE_CNT\n");
        exit(EXIT_FAILURE);
    }
    state_cache->states[state_cache->state_cnt] = *state;
    ++state_cache->state_cnt;
}

struct state *find_state(struct state_cache *state_cache, struct state *state)
{
    fprintf(stderr, "looking in state cache of size %zu\n", state_cache->state_cnt);
    for(size_t i = 0; i < state_cache->state_cnt; ++i) {
        if(compareable(state, &state_cache->states[i])) {
            return &state_cache->states[i];
        }
    }
    return NULL;
}

int main(int argc, char**argv)
{
    (void) argc;
    (void) argv;
    static struct state_cache state_cache = {0};
    struct field init_field = {0};
    struct state s = {
        .field= init_field,
        .p = {.x=2, .y=3},
        .direction_index = 0,
        .rock_cnt = 0,
    };
    while(true){
        enum rock r = rock_type(s.rock_cnt);
        enum direction d = jet_direction(s.direction_index);
        int64_t total_rocks = 1000000000000;
        bool ending = false;
        struct position p_push = {s.p.x + ((d==LEFT)? (-1) : 1), s.p.y};
        if(!occupied(&s.field, p_push, r)) {
            s.p = p_push;
        }
        struct position p_drop = {s.p.x, s.p.y - 1};
        if(!occupied(&s.field, p_drop, r)) {
            s.p = p_drop;
        } else {
            occupy(&s.field, s.p, r);
            /* print_field(&field, p.x, p.y, r); */
            struct position p_reset = {.x=2, .y=tower_height(&s.field) + 3};
            s.p = p_reset;
            s.rock_cnt ++;
            struct state *previous = find_state(&state_cache, &s);
            if (previous != NULL && !ending) {
                size_t h_previous = previous->field.offset + tower_height(&previous->field);
                size_t h_now = s.field.offset + tower_height(&s.field);
                size_t rock_cnt_prevous = previous->rock_cnt;
                size_t rock_cnt_now = s.rock_cnt;
                int64_t rock_delta = rock_cnt_now - rock_cnt_prevous;
                size_t tower_delta = h_now - h_previous;
                fprintf(stderr, "Previous height = %zu, now = %zu\n", h_previous, h_now);
                fprintf(stderr, "Previous rock_cnt = %zu, now = %zu\n", rock_cnt_prevous, rock_cnt_now);
                fprintf(stderr, "rock_delta = %zu\n", rock_delta);
                while(s.rock_cnt + rock_delta < total_rocks) {
                    s.rock_cnt+=rock_delta;
                    s.field.offset+=tower_delta;
                }
                ending = true;

                /* exit(EXIT_FAILURE); */
            }
            cache_state(&state_cache, &s);
            fprintf(stderr, "rock_cnt %ld\n", s.rock_cnt);
            fprintf(stderr, "tower_height %zu\n", s.field.offset + tower_height(&s.field));
            if(s.rock_cnt == total_rocks) {
                break;
            }
        }
        s.direction_index+=1;
    }

    size_t h = s.field.offset + tower_height(&s.field);
    fprintf(stdout, "SOLUTION tower_height=%zu\n", h);
    fprintf(stdout, (h == 3215) ? "SUCCESS\n" : "FAIL\n");

    return 1;
}
